@comment{"This is where the generation starts"}
@comment{"==================================="}

/*\n
 * Copyright 2014 Red Hat, Inc.\n
 *\n
 * Red Hat licenses this file to you under the Apache License, version 2.0\n
 * (the "License"); you may not use this file except in compliance with the\n
 * License.  You may obtain a copy of the License at:\n
 *\n
 * http://www.apache.org/licenses/LICENSE-2.0\n
 *\n
 * Unless required by applicable law or agreed to in writing, software\n
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n
 * License for the specific language governing permissions and limitations\n
 * under the License.\n
 */\n\n

package @{ifacePackageName.replace("io.vertx.", "io.vertx.groovy.")};\n

@declare{'invokeDelegate'}
@if{method.staticMethod}@{helper.getNonGenericType(ifaceFQCN)}@else{}@includeNamed{'rewriteDelegate';method=method}@end{}.@{method.name}(@foreach{param: method.params}@includeNamed{'paramArgument';param=param}@end{', '})
@end{}

@declare{'rewriteDelegate'}
@if{method.ownerTypes.size() > 1}
( /* Work around for https://jira.codehaus.org/browse/GROOVY-6970 */ (@{method.ownerTypes.iterator().next().name}) delegate)
@else{}
delegate
@end{}
@end{}

@declare{'paramTemplate'}
	@if{param.type.kind.name() == "OPTIONS"}
		Map<String, Object> @{param.name}
	@else{}
		@{param.type.simpleName} @{param.name}
	@end{}
@end{}

@declare{'paramArgument'}
	@if{param.type.kind.name() == "OPTIONS"}
		new @{param.type.name}(new io.vertx.core.json.JsonObject(@{param.name}))
	@else{param.type.kind.name() == "API"}
		@{param.name}.delegate
	@else{param.type.kind.name() == "OBJECT"}
		io.vertx.lang.groovy.Converter.unwrapObject(@{param.name})
	@else{param.type.kind.name() == "HANDLER"}
		@code{eventType=param.type.typeArguments[0]}
		@code{eventKind=eventType.kind.name()}
		@if{eventKind == "OTHER" || eventType.kind.basic}
			@{param.name}
		@else{eventKind == "LIST" || eventKind == "SET"}
			@code{elementType=eventType.typeArguments[0]}
			@code{elementKind=elementType.kind.name()}
			@if{elementKind=="PRIMITIVE"||elementKind=="BOXED_PRIMITIVE"||elementKind=="STRING"}
				@{param.name}
			@else{}
				null
			@end{}
		@else{eventKind == "API"}
			new Handler<@{eventType.raw.name}>() { public void handle(@{eventType.raw.name} event) { @{param.name}.handle(new @{eventType.raw.simpleName}(event)); } }
		@else{eventKind == "ASYNC_RESULT"}
			@code{asyncResultType=eventType.typeArguments[0]}
			@code{asyncResultKind=asyncResultType.kind.name()}
			@if{asyncResultKind == "OTHER" || asyncResultType.kind.basic}
				@{param.name}
			@else{asyncResultKind == "LIST" || asyncResultKind == "SET"}
				@code{elementType=asyncResultType.typeArguments[0]}
				@code{elementKind=elementType.kind.name()}
				@if{elementKind=="PRIMITIVE"||elementKind=="BOXED_PRIMITIVE"||elementKind=="STRING"}
					@{param.name}
				@else{}
					null
				@end{}
			@else{asyncResultKind == "API"}
				new AsyncResultHandlerAdapter<>(@{param.name})
			@else{}
				null /* Handler<AsyncResult> not yet handled */
			@end{}
		@else{}
			null /* Handler not yet handled */
		@end{}
	@else{}
		@{param.name}
	@end{}
@end{}

@declare{'returnTypeTemplate'}
	@if{type.kind.name() == "JSON_OBJECT"}
		Map<String, Object>
	@else{type.kind.name() == "JSON_ARRAY"}
		List<Object>
	@else{}
		@{type.simpleName}
	@end{}
@end{}

import groovy.transform.CompileStatic\n
import io.vertx.lang.groovy.AsyncResultHandlerAdapter\n
import io.vertx.lang.groovy.HandlerAdapter\n
@comment{"Generate the imports"}
@foreach{importedType:importedTypes}
	@if{importedType.kind.name() == "API"}
		@if{!ifacePackageName.equals(importedType.packageName)}
			import @{importedType.toString().replace("io.vertx.", "io.vertx.groovy.")}\n
		@end{}
	@else{}
		@if{!importedType.packageName.equals("java.lang")}
			import @{importedType}\n
		@end{}
	@end{}
@end{}

@CompileStatic\n
public @if{concrete}class@else{}interface@end{} @{helper.getSimpleName(ifaceFQCN)}

@if{concrete}
	@if{concreteSuperTypes.size() > 0}
	 extends
		@foreach{concreteSuperType: concreteSuperTypes}
		 @{concreteSuperType.simpleName}
		@end{}
	@end{}
@end{}

@if{abstractSuperTypes.size() > 0}
	 @if{concrete}implements@else{}extends@end{}
	@foreach{abstractSuperType: abstractSuperTypes}
	 @{abstractSuperType.simpleName}
	@end{', '}
@end{} {\n

@if{concrete}

	  final def @{helper.getNonGenericType(ifaceFQCN)} delegate;\n
	  public @{ifaceSimpleName}(@{helper.getNonGenericType(ifaceFQCN)} delegate) {\n
	@if{concrete && concreteSuperTypes.size() > 0}
	    super(delegate);\n
	@end{}
	    this.delegate = delegate;\n
	  }\n

	  public @{ifaceFQCN} getDelegate() {\n
	    return delegate;\n
	  }\n

	@foreach{method:methods}
	  public @if{method.staticMethod}static @end{}@if{method.typeParams.size() > 0}<@foreach{typeVar:method.typeParams}@{typeVar}@end{}> @end{}@includeNamed{'returnTypeTemplate';type=method.returnType} @{method.name}(@foreach{param: method.params}@includeNamed{'paramTemplate';param=param}@end{', '}) {\n
	@if{method.fluent}
	    @includeNamed{'invokeDelegate';method:method};\n
	    return this;\n
	@else{method.returnType.name.equals('void')}
	    @includeNamed{'invokeDelegate';method:method};\n
	@else{!method.returnType.name.startsWith('io.vertx.')}
	    return @includeNamed{'invokeDelegate';method:method};\n
	@else{method.returnType.kind.name() == "JSON_OBJECT"}
	    return @includeNamed{'invokeDelegate';method:method}.toMap();
	@else{method.returnType.kind.name() == "JSON_ARRAY"}
	    return @includeNamed{'invokeDelegate';method:method}.toList();
	@else{}
	    return new @{method.returnType.simpleName}(@includeNamed{'invokeDelegate';method:method});\n
	@end{}
	  }\n
	@end{}

@else{}

	  @{ifaceFQCN} getDelegate();\n

	@foreach{method:methods}
	  @if{method.staticMethod}static @end{}@if{method.typeParams.size() > 0}<@foreach{typeVar:method.typeParams}@{typeVar}@end{}> @end{}@{method.returnType.simpleName} @{method.name}(@foreach{param: method.params}@includeNamed{'paramTemplate';param=param}@end{', '});\n
	@end{}

@end{}
}\n